---
# File: ansible/playbook.yml
# Purpose: Fully idempotent Vault bootstrap via HTTP API from inside Docker
# Notes:
#   - Uses VAULT_ADDR from environment (e.g., https://vault.sttlab.local:8200)
#   - Assumes TLS is enabled on Vault; validate_certs is disabled to avoid CA distribution complexity
#   - Expects these host-mounted files:
#       /bootstrap/policy.hcl      -> Vault ACL policy text
#       /bootstrap/approle.env     -> Key=Value pairs for AppRole parameters
#       /bootstrap/secrets.json    -> JSON object with secrets to put under KV path
#   - Writes artifacts to /out:
#       init.json, unseal_key, root_token, role_id, secret_id, client_token

- hosts: localhost
  gather_facts: false
  vars:
    vault_addr: "{{ lookup('env','VAULT_ADDR') | default('https://vault.sttlab.local:8200', true) }}"
    kv_mount:   "{{ lookup('env','VAULT_KV_MOUNT') | default('secret', true) }}"
    kv_path:    "{{ lookup('env','VAULT_KV_PATH')  | default('msr', true) }}"
    transit_key: "{{ lookup('env','VAULT_TRANSIT_KEY') | default('msr-key', true) }}"
    out_dir: "/out"

  tasks:
    # -------------------------------------------------------------------------
    # Initialization / Unseal (first run)
    # -------------------------------------------------------------------------
    - name: Check init status
      uri:
        url: "{{ vault_addr }}/v1/sys/init"
        method: GET
        validate_certs: no
      register: init_status

    - name: Init Vault (only if not initialized)
      when: not init_status.json.initialized
      uri:
        url: "{{ vault_addr }}/v1/sys/init"
        method: PUT
        body_format: json
        body:
          secret_shares: 1
          secret_threshold: 1
        return_content: yes
        validate_certs: no
      register: init_result
      changed_when: true

    - name: Save init artifacts (init.json)
      when: not init_status.json.initialized
      copy:
        content: "{{ init_result.content }}"
        dest: "{{ out_dir }}/init.json"
        mode: "0600"

    - name: Extract unseal key and root token from init result
      when: not init_status.json.initialized
      set_fact:
        unseal_key: "{{ (init_result.json.keys_base64 | first) }}"
        root_token: "{{ init_result.json.root_token }}"

    - name: Unseal Vault (single share)
      when: not init_status.json.initialized
      uri:
        url: "{{ vault_addr }}/v1/sys/unseal"
        method: PUT
        body_format: json
        body: { key: "{{ unseal_key }}" }
        validate_certs: no

    - name: Persist unseal key
      when: not init_status.json.initialized
      copy:
        content: "{{ unseal_key }}"
        dest: "{{ out_dir }}/unseal_key"
        mode: "0600"

    - name: Persist root token
      when: not init_status.json.initialized
      copy:
        content: "{{ root_token }}"
        dest: "{{ out_dir }}/root_token"
        mode: "0600"

    # -------------------------------------------------------------------------
    # Acquire a root token for subsequent operations (idempotent)
    # Handles cases:
    #   A) fresh init -> root_token var defined above
    #   B) already initialized but root_token file exists
    #   C) already initialized, root_token file missing -> regenerate using unseal_key
    # -------------------------------------------------------------------------
    - name: Check root_token file
      stat:
        path: "{{ out_dir }}/root_token"
      register: root_token_stat

    - name: Load root token from file if present
      when: root_token is not defined and root_token_stat.stat.exists
      slurp:
        src: "{{ out_dir }}/root_token"
      register: root_token_file

    # --- Unseal on restart if Vault is initialized but sealed ---------------------

    - name: Check current seal status
      uri:
        url: "{{ vault_addr }}/v1/sys/seal-status"
        method: GET
        validate_certs: false
        status_code: [200]
      register: seal_status

    # If we don't yet have the unseal key in memory, read it from /out/unseal_key
    - name: Stat unseal key file
      stat:
        path: "{{ out_dir }}/unseal_key"
      register: unseal_key_stat
      when: seal_status.json.sealed | default(false)

    - name: Load unseal key (base64) from file
      slurp:
        src: "{{ out_dir }}/unseal_key"
      register: unseal_key_file
      when:
        - seal_status.json.sealed | default(false)
        - unseal_key is not defined
        - unseal_key_stat.stat.exists

    - name: Set unseal key fact from file (decoded)
      set_fact:
        unseal_key: "{{ unseal_key_file.content | b64decode | trim }}"
      when:
        - seal_status.json.sealed | default(false)
        - unseal_key is not defined
        - unseal_key_file is defined

    - name: Fail if Vault is sealed and unseal key is unavailable
      fail:
        msg: "Vault is sealed but {{ out_dir }}/unseal_key is missing. Provide the file or clear the data volume to reinitialize."
      when:
        - seal_status.json.sealed | default(false)
        - unseal_key is not defined

    - name: Unseal Vault (single share) if sealed
      uri:
        url: "{{ vault_addr }}/v1/sys/unseal"
        method: PUT
        validate_certs: false
        headers:
          Content-Type: application/json
        body_format: json
        body:
          key: "{{ unseal_key }}"
        status_code: [200]
      register: unseal_attempt
      when: seal_status.json.sealed | default(false)

    # Double-check and wait until unsealed (handles brief race conditions)
    - name: Wait until Vault is unsealed
      uri:
        url: "{{ vault_addr }}/v1/sys/seal-status"
        method: GET
        validate_certs: false
        status_code: [200]
      register: seal_check
      until: not (seal_check.json.sealed | default(true))
      retries: 10
      delay: 1
      when: seal_status.json.sealed | default(false)


    - name: Check unseal_key file (for potential root regeneration)
      when: root_token is not defined and not root_token_stat.stat.exists
      stat:
        path: "{{ out_dir }}/unseal_key"
      register: unseal_key_stat

    - name: Fail if no root token and no unseal key are available
      when: root_token is not defined and not root_token_stat.stat.exists and not unseal_key_stat.stat.exists
      fail:
        msg: >-
          Vault is initialized but /out/root_token is missing and /out/unseal_key not found.
          Provide these files or clear the vault-data volume to reinitialize cleanly.

    - name: Read unseal key (base64) for generate-root
      when: root_token is not defined and not root_token_stat.stat.exists and unseal_key_stat.stat.exists
      slurp:
        src: "{{ out_dir }}/unseal_key"
      register: unseal_key_file

    - name: Create OTP for root token regeneration
      when: root_token is not defined and not root_token_stat.stat.exists and unseal_key_stat.stat.exists
      set_fact:
        genroot_otp: "{{ lookup('password', '/dev/null', length=32) }}"
      no_log: true

    - name: Start generate-root attempt (obtain nonce)
      when: root_token is not defined and not root_token_stat.stat.exists and unseal_key_stat.stat.exists
      uri:
        url: "{{ vault_addr }}/v1/sys/generate-root/attempt"
        method: POST
        body_format: json
        body:
          otp: "{{ genroot_otp }}"
        validate_certs: no
      register: gen_attempt

    - name: Provide unseal key share (generate-root update)
      when: root_token is not defined and not root_token_stat.stat.exists and unseal_key_stat.stat.exists
      uri:
        url: "{{ vault_addr }}/v1/sys/generate-root/update"
        method: PUT
        body_format: json
        body:
          key: "{{ (unseal_key_file.content | b64decode | trim) }}"
          nonce: "{{ gen_attempt.json.nonce }}"
        validate_certs: no
      register: gen_update

    - name: Decode the encoded root token using OTP
      when: root_token is not defined and not root_token_stat.stat.exists and unseal_key_stat.stat.exists
      uri:
        url: "{{ vault_addr }}/v1/sys/decode-token"
        method: POST
        body_format: json
        body:
          encoded_token: "{{ gen_update.json.encoded_root_token }}"
          otp: "{{ genroot_otp }}"
        validate_certs: no
      register: gen_decode
      no_log: true

    - name: Persist regenerated root token
      when: root_token is not defined and not root_token_stat.stat.exists and unseal_key_stat.stat.exists
      copy:
        content: "{{ gen_decode.json.token }}"
        dest: "{{ out_dir }}/root_token"
        mode: "0600"
      no_log: true

    - name: Build Vault auth header for subsequent API calls
      set_fact:
        vault_headers:
          X-Vault-Token: >-
            {{ (root_token
                | default((root_token_file.content | b64decode | trim)
                          if root_token_file is defined
                          else (gen_decode.json.token))) }}

    # -------------------------------------------------------------------------
    # Enable KV v2 and write policy/AppRole/Transit/Secrets (idempotent)
    # -------------------------------------------------------------------------
    - name: Enable KV v2 at mount path
      uri:
        url: "{{ vault_addr }}/v1/sys/mounts/{{ kv_mount }}"
        method: POST
        headers: "{{ vault_headers }}"
        body_format: json
        status_code: [200,204,400]
        body:
          type: kv
          options: { version: "2" }
        validate_certs: no
      register: kv_enable
      failed_when: kv_enable.status not in [200,204,400]

    - name: Write ACL policy "msr"
      uri:
        url: "{{ vault_addr }}/v1/sys/policies/acl/msr"
        method: PUT
        headers: "{{ vault_headers }}"
        body_format: json
        body:
          policy: "{{ lookup('file','/bootstrap/policy.hcl') }}"
        status_code: [200, 204]
        validate_certs: no
      register: policy_write
      changed_when: policy_write.status in [200, 204]


    - name: Enable AppRole auth method
      uri:
        url: "{{ vault_addr }}/v1/sys/auth/approle"
        method: POST
        headers: "{{ vault_headers }}"
        body_format: json
        status_code: [200,204,400]
        body: { type: "approle" }
        validate_certs: no
      register: approle_enable
      failed_when: approle_enable.status not in [200,204,400]

    - name: Parse approle.env to key=value dictionary
      shell: |
        awk -F= '!/^(\s*#|\s*$)/{printf "%s=%s\n",$1,$2}' /bootstrap/approle.env
      args:
        executable: /bin/sh
      register: approle_env
      changed_when: false

    - name: Build AppRole payload
      set_fact:
        approle_body: "{{ dict(approle_env.stdout_lines | map('split','=',1) | list) | combine({'policies':'msr'}) }}"

    - name: Create/Update AppRole "msr"
      uri:
        url: "{{ vault_addr }}/v1/auth/approle/role/msr"
        method: POST
        headers: "{{ vault_headers }}"
        body_format: json
        body: "{{ approle_body }}"
        status_code: [200, 204]   # Vault returns 204 on success
        validate_certs: no
      register: approle_write
      changed_when: approle_write.status in [200, 204]


    - name: Read role_id
      uri:
        url: "{{ vault_addr }}/v1/auth/approle/role/msr/role-id"
        method: GET
        headers: "{{ vault_headers }}"
        validate_certs: no
      register: rid

    - name: Issue a new secret_id
      uri:
        url: "{{ vault_addr }}/v1/auth/approle/role/msr/secret-id"
        method: POST
        headers: "{{ vault_headers }}"
        validate_certs: no
      register: sid

    - name: Persist role_id and secret_id
      copy:
        content: "{{ rid.json.data.role_id }}"
        dest: "{{ out_dir }}/role_id"
        mode: "0600"
    - name: Persist secret_id
      copy:
        content: "{{ sid.json.data.secret_id }}"
        dest: "{{ out_dir }}/secret_id"
        mode: "0600"

    - name: Login with AppRole to get a client token
      uri:
        url: "{{ vault_addr }}/v1/auth/approle/login"
        method: POST
        body_format: json
        body:
          role_id:   "{{ rid.json.data.role_id }}"
          secret_id: "{{ sid.json.data.secret_id }}"
        validate_certs: no
      register: login

    # Normalize {{ out_dir }}/client_token so it is a file (not a directory)
    - name: Stat client_token path
      stat:
        path: "{{ out_dir }}/client_token"
      register: client_token_path

    - name: Remove client_token directory to normalize to file
      file:
        path: "{{ out_dir }}/client_token"
        state: absent
      when: client_token_path.stat.exists and client_token_path.stat.isdir

    # (Optional) ensure parent dir exists, harmless if already there
    - name: Ensure out_dir exists
      file:
        path: "{{ out_dir }}"
        state: directory
        mode: "0755"


    - name: Persist client token
      copy:
        content: "{{ login.json.auth.client_token }}"
        dest: "{{ out_dir }}/client_token"
        mode: "0600"

    - name: Enable Transit engine
      uri:
        url: "{{ vault_addr }}/v1/sys/mounts/transit"
        method: POST
        headers: "{{ vault_headers }}"
        body_format: json
        status_code: [200,204,400]
        body: { type: "transit" }
        validate_certs: no
      register: transit_enable
      failed_when: transit_enable.status not in [200,204,400]

    - name: Create transit key if missing
      uri:
        url: "{{ vault_addr }}/v1/transit/keys/{{ transit_key }}"
        method: POST
        headers: "{{ vault_headers }}"
        body_format: json
        body: { type: "aes256-gcm96" }
        status_code: [200,204,400]
        validate_certs: no
      register: tkey
      failed_when: tkey.status not in [200,204,400]

    - name: Write KV secrets (KV v2)
      uri:
        url: "{{ vault_addr }}/v1/{{ kv_mount }}/data/{{ kv_path }}"
        method: POST
        headers: "{{ vault_headers }}"
        body_format: json
        body: "{{ {'data': (lookup('file','/bootstrap/secrets.json') | from_json)} }}"
        validate_certs: no
